# Window Functions Introduction

### **Definition**

Window functions in SQL perform calculations across a set of table rows related to the current row. Unlike aggregate functions, which return a single result for a group of rows, window functions retain the original row details while providing additional calculated values. This makes them essential for advanced data analysis, where maintaining detailed row-level information while adding derived metrics is crucial.

---

### **Key Features of Window Functions**

1. **Retains Original Rows**: Window functions do not collapse rows; they calculate additional values for each row. The original dataset remains intact, with extra columns providing the results of calculations.
2. **Enhanced Analytics**: These functions enable complex analytics such as ranking, running totals, moving averages, cumulative sums, and lag/lead analysis. They are especially valuable for creating business reports and dashboards.
3. **Syntax Components**:
    
    ```sql
    <window_function>() OVER (
        [PARTITION BY <partition_column>]
        [ORDER BY <order_column>]
        [ROWS | RANGE <frame_clause>]
    )
    
    ```
    
    - **PARTITION BY**: Divides the result set into subsets based on specified columns (optional). Calculations are performed separately for each subset.
    - **ORDER BY**: Defines the order of rows within each partition (optional). Useful for ranking or cumulative calculations.
    - **ROWS | RANGE**: Specifies the frame of rows within the partition for the calculation (optional). It can define precise boundaries, such as rows before or after the current row.

---

### **Window vs Aggregate Functions**

| **Aspect** | **Aggregate Functions (GROUP BY)** | **Window Functions** |
| --- | --- | --- |
| **Purpose** | Summarize data by collapsing rows into groups. | Calculate additional values without collapsing rows. |
| **Result Set** | Fewer rows (one per group). | Same number of rows as the original dataset. |
| **Functions Supported** | Aggregate functions (`SUM()`, `COUNT()`, etc.). | Ranking, aggregation, and navigation functions. |
| **Syntax Example** | `GROUP BY column_name` | `<function> OVER (PARTITION BY column_name)` |

Window functions are more flexible than aggregate functions because they allow detailed and contextual row-level calculations without losing granular information.

---

### **Common Window Functions**

1. **ROW_NUMBER()**: Assigns a unique sequential number to rows within a partition. Often used for identifying duplicate records or selecting specific rows.
    
    ```sql
    SELECT
        employee_id,
        department_id,
        ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) AS rank
    FROM employees;
    
    ```
    
2. **RANK()**: Assigns a rank to rows, with gaps in ranks for ties. This is particularly useful in competitions or hierarchical data.
    
    ```sql
    SELECT
        employee_id,
        department_id,
        RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS rank
    FROM employees;
    
    ```
    
3. **DENSE_RANK()**: Similar to `RANK()`, but without gaps in ranks for ties. Useful for assigning compact ranks.
    
    ```sql
    SELECT
        employee_id,
        department_id,
        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS dense_rank
    FROM employees;
    
    ```
    
4. **SUM(), AVG(), MIN(), MAX()**: Compute aggregates across a window of rows, retaining the original row data. Examples include calculating total sales or average salaries per department.
    
    ```sql
    SELECT
        employee_id,
        department_id,
        salary,
        SUM(salary) OVER (PARTITION BY department_id) AS total_salary
    FROM employees;
    
    ```
    
5. **LEAD() and LAG()**: Access data in subsequent or preceding rows. These functions are valuable for trend analysis or comparing values across rows.
    
    ```sql
    SELECT
        employee_id,
        salary,
        LEAD(salary) OVER (ORDER BY employee_id) AS next_salary,
        LAG(salary) OVER (ORDER BY employee_id) AS prev_salary
    FROM employees;
    
    ```
    

---

### **Window Functions vs GROUP BY Examples**

- **GROUP BY Example**:
    
    ```sql
    SELECT department_id, SUM(salary) AS total_salary
    FROM employees
    GROUP BY department_id;
    
    ```
    
    - **Output**: One row per `department_id`. The data is aggregated and grouped, collapsing individual rows.
- **Window Function Example**:
    
    ```sql
    SELECT
        employee_id,
        department_id,
        salary,
        SUM(salary) OVER (PARTITION BY department_id) AS total_salary
    FROM employees;
    
    ```
    
    - **Output**: All rows are retained, and an additional column (`total_salary`) is added. This enables row-level analytics while showing aggregate metrics.

---

### **Advanced Use Cases**

1. **Cumulative Totals**:
Cumulative totals are commonly used in financial and sales reports to track running totals across periods or categories.
    
    ```sql
    SELECT
        employee_id,
        department_id,
        salary,
        SUM(salary) OVER (PARTITION BY department_id ORDER BY hire_date) AS cumulative_salary
    FROM employees;
    
    ```
    
2. **Moving Averages**:
Moving averages smooth out fluctuations in data and are commonly used in stock price analysis or sales trends.
    
    ```sql
    SELECT
        employee_id,
        salary,
        AVG(salary) OVER (ORDER BY hire_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS moving_avg
    FROM employees;
    
    ```
    
3. **Ranked Results**:
Rank employees or products based on performance metrics such as sales or ratings.
    
    ```sql
    SELECT
        employee_id,
        salary,
        RANK() OVER (ORDER BY salary DESC) AS salary_rank
    FROM employees;
    
    ```
    
4. **First and Last Value**:
Retrieve the first or last value within a window frame. This is useful for time-series analysis.
    
    ```sql
    SELECT
        employee_id,
        salary,
        FIRST_VALUE(salary) OVER (PARTITION BY department_id ORDER BY hire_date) AS first_salary,
        LAST_VALUE(salary) OVER (PARTITION BY department_id ORDER BY hire_date ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_salary
    FROM employees;
    
    ```
    

---

### **Summary**

- **GROUP BY**: Groups rows into buckets, returning one result per group. It is primarily used for summary reports where row-level detail is not needed.
- **Window Functions**: Extend each row with additional calculations over defined "windows." They provide more flexibility and power for detailed analytics without losing original data granularity.

By mastering window functions, SQL developers can unlock advanced analytical capabilities and create queries that deliver both detail and insights, making them indispensable for modern data analysis and reporting.
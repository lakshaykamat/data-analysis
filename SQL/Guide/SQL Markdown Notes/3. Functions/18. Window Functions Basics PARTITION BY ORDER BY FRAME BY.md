# Window Functions Basics

### **PARTITION BY**

The `PARTITION BY` clause divides a dataset into subsets, called partitions, based on the values of specified columns. Window functions are then applied independently to each partition.

- **Purpose**: To perform calculations separately for each group of rows within a dataset.
- **Optional Clause**: If omitted, the entire dataset is treated as a single partition.

**Syntax:**

```sql
<window_function>() OVER (PARTITION BY column_name)
```

**Example:**
To calculate the total salary for each department:

```sql
SELECT
    employee_id,
    department_id,
    salary,
    SUM(salary) OVER (PARTITION BY department_id) AS total_salary
FROM employees;
```

| **Employee ID** | **Department ID** | **Salary** | **Total Salary** |
| --- | --- | --- | --- |
| 1 | 101 | 5000 | 15000 |
| 2 | 101 | 7000 | 15000 |
| 3 | 101 | 3000 | 15000 |
| 4 | 102 | 6000 | 11000 |
| 5 | 102 | 5000 | 11000 |

---

### **ORDER BY**

The `ORDER BY` clause defines the sequence of rows within each partition. It is particularly useful for calculations that depend on row order, such as rankings, cumulative sums, and moving averages.

- **Purpose**: To impose a specific order for row-by-row operations.
- **Optional Clause**: If omitted, the functionâ€™s behavior may not depend on row order.

**Syntax:**

```sql
<window_function>() OVER (PARTITION BY column_name ORDER BY column_name)
```

**Example:**
To assign a rank to employees within each department based on their salary:

```sql
SELECT
    employee_id,
    department_id,
    salary,
    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS salary_rank
FROM employees;
```

| **Employee ID** | **Department ID** | **Salary** | **Salary Rank** |
| --- | --- | --- | --- |
| 2 | 101 | 7000 | 1 |
| 1 | 101 | 5000 | 2 |
| 3 | 101 | 3000 | 3 |
| 4 | 102 | 6000 | 1 |
| 5 | 102 | 5000 | 2 |

---

### **FRAME Clause**

The `FRAME` clause specifies a subset of rows within a partition to include in the calculation. It refines the `ORDER BY` clause by explicitly defining a "window frame."

- **Purpose**: To limit the range of rows considered for calculations.
- **Optional Clause**: If omitted, default behavior is defined by the function.

**Syntax:**

```sql
ROWS | RANGE [frame_start] AND [frame_end]
```

- **ROWS**: Specifies a fixed number of rows relative to the current row.
- **RANGE**: Considers rows with values within a specified range relative to the current row.

**Frame Boundaries:**

- `UNBOUNDED PRECEDING`: Includes all rows from the start of the partition to the current row.
- `CURRENT ROW`: Includes only the current row.
- `UNBOUNDED FOLLOWING`: Includes all rows from the current row to the end of the partition.
- `n PRECEDING`: Includes `n` rows before the current row.
- `n FOLLOWING`: Includes `n` rows after the current row.

**Example 1: Cumulative Sum**

```sql
SELECT
    employee_id,
    department_id,
    salary,
    SUM(salary) OVER (
        PARTITION BY department_id
        ORDER BY hire_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_salary
FROM employees;
```

| **Employee ID** | **Department ID** | **Salary** | **Cumulative Salary** |
| --- | --- | --- | --- |
| 1 | 101 | 5000 | 5000 |
| 2 | 101 | 7000 | 12000 |
| 3 | 101 | 3000 | 15000 |
| 4 | 102 | 6000 | 6000 |
| 5 | 102 | 5000 | 11000 |

**Example 2: Moving Average**

```sql
SELECT
    employee_id,
    salary,
    AVG(salary) OVER (
        ORDER BY hire_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS moving_avg
FROM employees;
```

| **Employee ID** | **Salary** | **Moving Average** |
| --- | --- | --- |
| 1 | 5000 | 5000 |
| 2 | 7000 | 6000 |
| 3 | 3000 | 5000 |
| 4 | 6000 | 5333.33 |
| 5 | 5000 | 4666.67 |

---

### **Key Differences Between ROWS and RANGE**

| **Aspect** | **ROWS** | **RANGE** |
| --- | --- | --- |
| **Definition** | Operates on physical row counts. | Operates on value ranges defined by `ORDER BY`. |
| **Behavior** | Always includes exact number of rows. | Includes rows with values falling within range. |
| **Use Case** | Fixed-size windows (e.g., 3 rows). | Value-based windows (e.g., dates within range). |

**Example: ROWS vs RANGE**

```sql
-- Using ROWS
SUM(salary) OVER (ORDER BY hire_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)

-- Using RANGE
SUM(salary) OVER (ORDER BY hire_date RANGE BETWEEN INTERVAL 30 DAY PRECEDING AND CURRENT ROW)
```

| **Employee ID** | **Salary** | **ROWS Sum** | **RANGE Sum** |
| --- | --- | --- | --- |
| 1 | 5000 | 5000 | 5000 |
| 2 | 7000 | 12000 | 12000 |
| 3 | 3000 | 15000 | 15000 |
| 4 | 6000 | 16000 | 13000 |
| 5 | 5000 | 14000 | 11000 |

---

By mastering `PARTITION BY`, `ORDER BY`, and `FRAME` clauses, you can unlock the full potential of SQL window functions for advanced analytical queries.